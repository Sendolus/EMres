import cv2
import sys
import numpy as np
import glob
import math
import statistics
import os
import itertools
import random
from collections import Counter
from opensimplex import OpenSimplex
from matplotlib.patches import Rectangle
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from matplotlib import collections as mc
import matplotlib.image as mpimg
import matplotlib.patches as patches
import matplotlib
from get_label_dict import get_dict_of_label_ids
sys.path.append('post_dcnn_inference')
from stave_line_detection import get_stave_line_candidates

label_dict = get_dict_of_label_ids()
inv_label_dict = {v: k for k, v in label_dict.items()}

color_dictionary = { 'minim': 'black', 'semibreve': 'crimson', 'obliqa': 'bisque', 'semiminim': 'violet',
                   'dot': 'fuchsia', 'dotted note': 'brown', 'rest': 'lime',     'breve': 'navy',
                   'barline': 'yellow', 'repeat': 'slategray',  'fermata': 'yellow',
                   'ligature':  'teal',    'lnote1': 'chocolate', 'lnote2': 'lavenderblush',
                   'l1colored breve': 'cyan','imin': 'mediumvioletred',   'flat': 'blue',
                    'fusa': 'darkorange', 'longa': 'slateblue','colored breve' : 'cyan',
                   'colored semibreve': 'lavenderblush', 'colored longa' : 'lightcyan',  'c clef': 'olivedrab',
                   'f clef': 'mintcream',  'g clef': 'lightcoral',  'imaj': 'darkorange',
                   'pmaj': 'darkkhaki', 'imincut': 'darkgreen', 'imincut': 'chocolate',
                   'pmin': 'saddlebrown', '3': 'mediumpurple',  '2': 'aliceblue', 'sharp': 'gold',
                   'fusa rest': 'cyan', 'semifusa':'aquamarine', '1': 'brown','custos' : 'teal',
                   'minim rest': 'teal', 'breve rest': 'pink', 'semibreve rest': 'yellowgreen',
                   'longa rest': 'slateblue', 'colored lnote1' :'green', 'colored lnote2': 'cyan',
                   'colored obliqa': 'yellow', 'white_black obliqa': 'purple', 'black_white obliqa':
                   'violet', 'pmincut': 'gray','l2colored breve': 'red','l1semibreve': 'crimson' ,
                  'l2semibreve': 'crimson', 'l1breve': 'navy', 'l2breve': 'navy',
                   'congruence': 'brown', 'o1semibreve': 'red', 'o2semibreve':'crimson',
                   'l1colored semibreve' : 'lavenderblush', 'o1colored semibreve': 'lavenderblush', 'o2breve' :'navy',
                   'o2colored semibreve' : 'lavenderblush','l1longa' : 'slateblue', 'o1breve': 'navy', 'o1colored breve':'cyan',
                  'l2colored semibreve' : 'lavenderblush', 'l2longa': 'slateblue', 'ornate element': 'purple',
                  'o2colored breve': 'cyan', 'l1': 'brown','l2': 'white', 'o1': 'red', 'o2': 'blue', 'colored l1': 'pink',
                  'colored l2': 'cyan', 'colored o1' : 'teal', 'colored o2': 'white',
                   'o1longa': 'slateblue' ,'o2longa': 'slateblue','l2colored longa': 'lightcyan','l1colored longa': 'lightcyan' }


def rescale_image(img_path, gray, scale_factor_width, scale_factor_height):
    """
    Rescales image using a scale_factor in the horizontal and vercical dimension
    """
    if gray:
        img = cv2.imread(img_path, 0)
    else:
        img = mpimg.imread(img_path)
    height, width = img.shape[0], img.shape[1]

    if scale_factor_width == None and scale_factor_height == None:
        scale_factor_width = 1
        scale_factor_height = 1
    img = cv2.resize(img, (int((width * scale_factor_width)), int(height * scale_factor_height)),
                     interpolation=cv2.INTER_NEAREST)
    return img


def make_note_training(parsed_folium, img_path, damage_prob):
    """
    Chooses a random note-type present on the page and picks one as LQ image together with 3 context examples.
    The low quality image is generated by occluding the note with Perlin noise
    """
    gray = False
    scale_factor_width, scale_factor_height = 1, 1
    image = rescale_image(img_path, gray, scale_factor_width, scale_factor_height)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    tmp = OpenSimplex(seed=np.random.randint(0, 10000))
    context_nb = 3

    boxes = []
    label_ids = []
    scores = []

    for staff_dict in parsed_folium:
        boxes.extend(staff_dict['boxes'])
        label_ids.extend(staff_dict['label_ids'])
        scores.extend(staff_dict['scores'])

    # Select an id that occurs more than context_nb times
    id_counts = Counter(label_ids)
    selected_ids = [id_ for id_, count in id_counts.items() if count > context_nb]
    selected_id = random.choice(selected_ids) if selected_ids else None

    # Find the context_nb + 1 notes with the highest scores
    matching = []
    for i in range(len(label_ids)):
        if label_ids[i] == selected_id:
            matching.append((scores[i], boxes[i]))

    matching.sort(reverse=True, key=lambda x: x[0])
    boxes = [box for _, box in matching[:context_nb+1]]

    # Process the selected notes
    context = []
    working_k = np.random.randint(0, context_nb+1)
    for k in range(context_nb+1):
        obj = boxes[k]
        x, y, w, h = obj[1], obj[0], obj[3] - obj[1], obj[2] - obj[0]
        resized = resize_keep_aspect(image[y:y+h, x:x+w])
        new_h, new_w, _ = resized.shape
        if k == working_k:
            HQ = resized.copy()
            for i in range(new_h):
                for j in range(new_w):
                    scale = 2 / new_h
                    value = tmp.noise2(i * scale, j * scale)
                    if value > damage_prob:
                        resized[i, j, :] = 255  # mark as damaged

            LQ = resized
        else:
            context.append(resized)
    return LQ, HQ, context


def resize_keep_aspect(image, target_longest_side=100):
    """
    Resize an image while keeping the aspect ratio
    """
    h, w = image.shape[:2]
    scale = target_longest_side / max(h, w)
    new_w = int(w * scale)
    new_h = int(h * scale)
    resized = cv2.resize(image, (new_w, new_h), interpolation=cv2.INTER_AREA)
    return resized


